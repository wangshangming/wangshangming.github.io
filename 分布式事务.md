[TOC]

## 场景

- 微服务架构下，保证多个服务数据一致性

- 表因为数据量太大而分库，在单个应用中操作多个数据库

## 2PC

```
Coordinator                                          Participant
                             QUERY TO COMMIT
                 -------------------------------->
                             VOTE YES/NO             prepare*/abort*
                 <-------------------------------
commit*/abort*               COMMIT/ROLLBACK
                 -------------------------------->
                             ACKNOWLEDGMENT          commit*/abort*
                 <--------------------------------  
end
```

## 解决方案

### XA (eXtended Architecture)

XA 是 X/Open 组织定义的一套基于 2PC 协议的规范，目的是保证跨异构组件的事务的原子性。所谓的 “异构组件” 可以是数据库、消息队列、应用服务器、缓存等等。

其中，X/Open 还定义了分布式事务处理模型（Distributed Transaction Processing，简称 DTP 模型）：



![DTP model](assets/分布式事务/DTP model.png)

XA 定义的规范：

![image-20210801223921321](assets/分布式事务/image-20210801223921321.png)

#### MySQL 对 XA 的支持

```sql
XA {START|BEGIN} xid [JOIN|RESUME]

XA END xid [SUSPEND [FOR MIGRATE]]

XA PREPARE xid

XA COMMIT xid [ONE PHASE]

XA ROLLBACK xid

XA RECOVER [CONVERT XID]
```

交互过程：

![mysql xa](assets/分布式事务/mysql xa.png)



```sql
mysql> XA START 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> INSERT INTO mytable (i) VALUES(10);
Query OK, 1 row affected (0.04 sec)

mysql> XA END 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> XA PREPARE 'xatest';
Query OK, 0 rows affected (0.00 sec)

mysql> XA COMMIT 'xatest';
Query OK, 0 rows affected (0.00 sec)
```

#### Seata 对 XA 的支持

##### 整体机制

![img](assets/分布式事务/TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png)

TM：定义全局事务的范围——开始全局事务、提交或回滚全局事务。

TC：全称 Transaction Coordinator，是 Seata 服务端（应用依赖的 Seata SDK 是客户端），维护全局和分支事务的状态，驱动全局事务提交或回滚。

RM：与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。

##### 用法

替换数据源：

```java
@Bean("dataSourceProxy")
public DataSource dataSource(DruidDataSource druidDataSource) {
	return new DataSourceProxyXA(druidDataSource);
}
```

声明式事务：

```java
@GlobalTransactional(timeoutMills = 1000000)
public void purchase(String userId, String commodityCode, int orderCount, boolean rollback) {
    String xid = RootContext.getXID();
    LOGGER.info("New Transaction Begins: " + xid);

    String result = storageFeignClient.deduct(commodityCode, orderCount);

    if (!SUCCESS.equals(result)) {
        throw new RuntimeException("库存服务调用失败,事务回滚!");
    }

    result = orderFeignClient.create(userId, commodityCode, orderCount);

    if (!SUCCESS.equals(result)) {
        throw new RuntimeException("订单服务调用失败,事务回滚!");
    }

    if (rollback) {
        throw new RuntimeException("Force rollback ... ");
    }
}
```

#### 优点

- 对业务透明，使用简单
- 一致性最高

#### 缺点

- 为了防止脏读，所有 SQL 必须要在串行化隔离级别执行，因此性能最差（可以考虑中间件层面搞个全局的 MVCC）
- 如果数据库在执行 `XA PREPARE, XA COMMIT, XA ROLLBACK, XA COMMIT ... ONE PHASE` 时宕机，重启后不能保证 binlog 的一致性
- 如果某个事务 `PREPARE` 后，迟迟没有 `COMMIT` 或 `ROLLBACK`，数据库不会自动释放锁，从而阻塞其它事务的执行

#### Seata 的 AT (Automatic Transaction) 模式

为了解决 XA 模式数据库长时间持有锁的问题，Seata 在 AT 模式下，不依赖数据库的锁来保证串行化，而是使用自己可控的全局锁。

##### 一阶段

![分布式事务-at模式-分支事务提交](assets/分布式事务/分布式事务-at模式-分支事务提交.png)

全局锁：锁住某个表中被修改的数据，根据表名、唯一键等字段生成

##### 二阶段-提交

![分布式事务-at模式-二阶段提交](assets/分布式事务/分布式事务-at模式-二阶段提交.png)

##### 二阶段-回滚

![分布式事务-at模式-二阶段回滚](assets/分布式事务/分布式事务-at模式-二阶段回滚.png)

##### 隔离性

读数据：默认是读未提交。如果要读已提交，则需要使用 `select ... for update` 语句，Seata 会自动请求全局锁。

写数据：如果两个事务都是分布式事务，则可以通过全局锁来串行化执行；如果一个是分布式事务，另一个是单机事务，则单机事务需要通过手动加全局锁，防止分布式事务回滚异常。

##### 跟 XA 模式相比：

优点：

- 性能高。单机事务提交前才会获取全局锁，减少加锁时间
- 稳定性高。全局锁可以设置超时时间，避免 XA 模式下数据一直被锁住

缺点：一致性相比 XA 模式会有所降低。

### TCC 

